<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Minor Engine: Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Minor Engine
   &#160;<span id="projectnumber">0.0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../dd/de7/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a wrapper for the native methods of the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> Enqueued Commands API.  
 <a href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0012554c7ef3f6eec4d67274b159420f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#a0012554c7ef3f6eec4d67274b159420f">EnqueueReadBuffer</a> ([In] IntPtr commandQueue, [In] IntPtr buffer, [In] [MarshalAs(UnmanagedType.U4)] uint blockingRead, [In] UIntPtr offset, [In] UIntPtr size, [In] IntPtr pointer, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:a0012554c7ef3f6eec4d67274b159420f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue commands to read from a buffer object to host memory.  <a href="#a0012554c7ef3f6eec4d67274b159420f">More...</a><br /></td></tr>
<tr class="separator:a0012554c7ef3f6eec4d67274b159420f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cac4992c3136e0bcb6fe6e74c9b2ae"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#aa2cac4992c3136e0bcb6fe6e74c9b2ae">EnqueueReadBufferRectangle</a> ([In] IntPtr commandQueue, [In] IntPtr buffer, [In] [MarshalAs(UnmanagedType.U4)] uint blockingRead, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] bufferOrigin, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] hostOrigin, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] region, [In] UIntPtr bufferRowPitch, [In] UIntPtr bufferSlicePitch, [In] UIntPtr hostRowPitch, [In] UIntPtr hostSlicePitch, [In] IntPtr pointer, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:aa2cac4992c3136e0bcb6fe6e74c9b2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue command to read from a 2D or 3D rectangular region from a buffer object to host memory.  <a href="#aa2cac4992c3136e0bcb6fe6e74c9b2ae">More...</a><br /></td></tr>
<tr class="separator:aa2cac4992c3136e0bcb6fe6e74c9b2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1793e532cd163b1c78963d99d1423080"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#a1793e532cd163b1c78963d99d1423080">EnqueueWriteBuffer</a> ([In] IntPtr commandQueue, [In] IntPtr buffer, [In] [MarshalAs(UnmanagedType.U4)] uint blockingWrite, [In] UIntPtr offset, [In] UIntPtr size, [In] IntPtr pointer, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:a1793e532cd163b1c78963d99d1423080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue commands to write to a buffer object from host memory.  <a href="#a1793e532cd163b1c78963d99d1423080">More...</a><br /></td></tr>
<tr class="separator:a1793e532cd163b1c78963d99d1423080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70d737cc3f6697f742c7d6bbe1ca954"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#af70d737cc3f6697f742c7d6bbe1ca954">EnqueueWriteBufferRectangle</a> ([In] IntPtr commandQueue, [In] IntPtr buffer, [In] [MarshalAs(UnmanagedType.U4)] uint blockingWrite, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] bufferOrigin, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] hostOrigin, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] region, [In] UIntPtr bufferRowPitch, [In] UIntPtr bufferSlicePitch, [In] UIntPtr hostRowPitch, [In] UIntPtr hostSlicePitch, [In] IntPtr pointer, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:af70d737cc3f6697f742c7d6bbe1ca954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue command to write a 2D or 3D rectangular region to a buffer object from host memory.  <a href="#af70d737cc3f6697f742c7d6bbe1ca954">More...</a><br /></td></tr>
<tr class="separator:af70d737cc3f6697f742c7d6bbe1ca954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f28918e717b0f4911809a9c25d044f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ab7f28918e717b0f4911809a9c25d044f">EnqueueFillBuffer</a> ([In] IntPtr commandQueue, [In] IntPtr buffer, [In] IntPtr pattern, [In] UIntPtr patternSize, [In] UIntPtr offset, [In] UIntPtr size, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:ab7f28918e717b0f4911809a9c25d044f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to fill a buffer object with a pattern of a given pattern size.  <a href="#ab7f28918e717b0f4911809a9c25d044f">More...</a><br /></td></tr>
<tr class="separator:ab7f28918e717b0f4911809a9c25d044f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4de495720879ccc8d62026a9e5891f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#a6c4de495720879ccc8d62026a9e5891f">EnqueueCopyBuffer</a> ([In] IntPtr commandQueue, [In] IntPtr sourceBuffer, [In] IntPtr destinationBuffer, [In] UIntPtr sourceOffset, [In] UIntPtr destinationOffset, [In] UIntPtr size, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:a6c4de495720879ccc8d62026a9e5891f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to copy from one buffer object to another.  <a href="#a6c4de495720879ccc8d62026a9e5891f">More...</a><br /></td></tr>
<tr class="separator:a6c4de495720879ccc8d62026a9e5891f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0ea05825a0696d2b864a9325eeab45"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#aab0ea05825a0696d2b864a9325eeab45">EnqueueCopyBufferRectangle</a> ([In] IntPtr commandQueue, [In] IntPtr sourceBuffer, [In] IntPtr destinationBuffer, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] sourceOrigin, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] destinationOrigin, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] region, [In] UIntPtr sourceRowPitch, [In] UIntPtr sourceSlicePitch, [In] UIntPtr destinationRowPitch, [In] UIntPtr destinationSlicePitch, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:aab0ea05825a0696d2b864a9325eeab45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to copy a 2D or 3D rectangular region from a buffer object to another buffer object.  <a href="#aab0ea05825a0696d2b864a9325eeab45">More...</a><br /></td></tr>
<tr class="separator:aab0ea05825a0696d2b864a9325eeab45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac523ddce2a890444ae03cc5bfa17bf21"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ac523ddce2a890444ae03cc5bfa17bf21">EnqueueReadImage</a> ([In] IntPtr commandQueue, [In] IntPtr image, [In] [MarshalAs(UnmanagedType.U4)] uint blockingRead, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] origin, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] region, [In] UIntPtr rowPitch, [In] UIntPtr slicePitch, [In] IntPtr pointer, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:ac523ddce2a890444ae03cc5bfa17bf21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue commands to read from an image or image array object to host memory.  <a href="#ac523ddce2a890444ae03cc5bfa17bf21">More...</a><br /></td></tr>
<tr class="separator:ac523ddce2a890444ae03cc5bfa17bf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277ec7cdcd85d5028219690e32812319"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#a277ec7cdcd85d5028219690e32812319">EnqueueWriteImage</a> ([In] IntPtr commandQueue, [In] IntPtr image, [In] [MarshalAs(UnmanagedType.U4)] uint blockingWrite, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] origin, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] region, [In] UIntPtr inputRowPitch, [In] UIntPtr inputSlicePitch, [In] IntPtr pointer, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:a277ec7cdcd85d5028219690e32812319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to write to an image or image array object from host memory.  <a href="#a277ec7cdcd85d5028219690e32812319">More...</a><br /></td></tr>
<tr class="separator:a277ec7cdcd85d5028219690e32812319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb3064e525732246d0c3344a951f739"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#adeb3064e525732246d0c3344a951f739">EnqueueFillImage</a> ([In] IntPtr commandQueue, [In] IntPtr image, [In] IntPtr fillColor, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] origin, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] region, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:adeb3064e525732246d0c3344a951f739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to fill an image object with a specified color.  <a href="#adeb3064e525732246d0c3344a951f739">More...</a><br /></td></tr>
<tr class="separator:adeb3064e525732246d0c3344a951f739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8424f6d9d2b5401d508e4a827f002b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#a7a8424f6d9d2b5401d508e4a827f002b">EnqueueCopyImage</a> ([In] IntPtr commandQueue, [In] IntPtr sourceImage, [In] IntPtr destinationImage, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] sourceOrigin, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] destinationOrigin, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] region, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:a7a8424f6d9d2b5401d508e4a827f002b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to copy image objects.  <a href="#a7a8424f6d9d2b5401d508e4a827f002b">More...</a><br /></td></tr>
<tr class="separator:a7a8424f6d9d2b5401d508e4a827f002b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf71756eda0bcb4246d48bed1ed6c885"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#adf71756eda0bcb4246d48bed1ed6c885">EnqueueCopyImageToBuffer</a> ([In] IntPtr commandQueue, [In] IntPtr sourceImage, [In] IntPtr destinationBuffer, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] sourceOrigin, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] region, [In] UIntPtr destinationOffset, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:adf71756eda0bcb4246d48bed1ed6c885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to copy an image object to a buffer object.  <a href="#adf71756eda0bcb4246d48bed1ed6c885">More...</a><br /></td></tr>
<tr class="separator:adf71756eda0bcb4246d48bed1ed6c885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77814dc417fc7d59edb59a97310d9732"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#a77814dc417fc7d59edb59a97310d9732">EnqueueCopyBufferToImage</a> ([In] IntPtr commandQueue, [In] IntPtr sourceBuffer, [In] IntPtr destinationImage, [In] UIntPtr sourceOffset, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] destinationOrigin, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] region, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:a77814dc417fc7d59edb59a97310d9732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to copy a buffer object to an image object.  <a href="#a77814dc417fc7d59edb59a97310d9732">More...</a><br /></td></tr>
<tr class="separator:a77814dc417fc7d59edb59a97310d9732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc19a7f173de66cf1b2d8b9db7e58ddf"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#adc19a7f173de66cf1b2d8b9db7e58ddf">EnqueueMapBuffer</a> ([In] IntPtr commandQueue, [In] IntPtr buffer, [In] [MarshalAs(UnmanagedType.U4)] uint blockingMap, [In] [MarshalAs(UnmanagedType.U8)] <a class="el" href="../../d3/d2b/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands.html#ad74eb478bb825816afea8657fc06400e">MapFlag</a> mapFlag, [In] UIntPtr offset, [In] UIntPtr size, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent, [Out] [MarshalAs(UnmanagedType.I4)] out <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> errorCode)</td></tr>
<tr class="memdesc:adc19a7f173de66cf1b2d8b9db7e58ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to map a region of the buffer object given by buffer into the host address space and returns a pointer to this mapped region.  <a href="#adc19a7f173de66cf1b2d8b9db7e58ddf">More...</a><br /></td></tr>
<tr class="separator:adc19a7f173de66cf1b2d8b9db7e58ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4a513f12c66e75c675810ecdaa36e0"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ade4a513f12c66e75c675810ecdaa36e0">EnqueueMapImage</a> ([In] IntPtr commandQueue, [In] IntPtr image, [In] [MarshalAs(UnmanagedType.U4)] uint blockingMap, [In] [MarshalAs(UnmanagedType.U8)] <a class="el" href="../../d3/d2b/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands.html#ad74eb478bb825816afea8657fc06400e">MapFlag</a> mapFlag, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] origin, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] region, [In] UIntPtr imageRowPitch, [In] UIntPtr imageSlicePitch, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent, [Out] [MarshalAs(UnmanagedType.I4)] out <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> errorCode)</td></tr>
<tr class="memdesc:ade4a513f12c66e75c675810ecdaa36e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to map a region of an image object into the host address space and returns a pointer to this mapped region.  <a href="#ade4a513f12c66e75c675810ecdaa36e0">More...</a><br /></td></tr>
<tr class="separator:ade4a513f12c66e75c675810ecdaa36e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88fb4660b2e42e6255eee66f7765b88"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#aa88fb4660b2e42e6255eee66f7765b88">EnqueueUnmapMemoryObject</a> ([In] IntPtr commandQueue, [In] IntPtr memoryObject, [In] IntPtr mappedPointer, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:aa88fb4660b2e42e6255eee66f7765b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to unmap a previously mapped region of a memory object.  <a href="#aa88fb4660b2e42e6255eee66f7765b88">More...</a><br /></td></tr>
<tr class="separator:aa88fb4660b2e42e6255eee66f7765b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf74d6492434979be80fbb4d6732dbea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#abf74d6492434979be80fbb4d6732dbea">EnqueueMigrateMemorysObjects</a> ([In] IntPtr commandQueue, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfMemoryObjects, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] memoryObjects, [In] [MarshalAs(UnmanagedType.U8)] <a class="el" href="../../d3/d2b/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands.html#a2a6e8133e55eb1fd7fb5fc882d75b902">MemoryMigrationFlag</a> memoryMigrationFlags, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:abf74d6492434979be80fbb4d6732dbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to indicate which device a set of memory objects should be associated with.  <a href="#abf74d6492434979be80fbb4d6732dbea">More...</a><br /></td></tr>
<tr class="separator:abf74d6492434979be80fbb4d6732dbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1475364cd3cfbfaea7a4ea8ea39c6c16"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#a1475364cd3cfbfaea7a4ea8ea39c6c16">EnqueueNDRangeKernel</a> ([In] IntPtr commandQueue, [In] IntPtr kernel, [In] [MarshalAs(UnmanagedType.U4)] uint workDimension, [In] IntPtr[] globalWorkOffset, [In] IntPtr[] globalWorkSize, [In] IntPtr[] localWorkSize, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:a1475364cd3cfbfaea7a4ea8ea39c6c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to execute a kernel on a device.  <a href="#a1475364cd3cfbfaea7a4ea8ea39c6c16">More...</a><br /></td></tr>
<tr class="separator:a1475364cd3cfbfaea7a4ea8ea39c6c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bdd10bc6712efec618737f6d7f2f83"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#a82bdd10bc6712efec618737f6d7f2f83">EnqueueNativeKernel</a> ([In] IntPtr commandQueue, [In] IntPtr userFunction, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] arguments, [In] UIntPtr argumentSize, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfMemoryObjects, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] memoryObjects, [In] IntPtr argumentsMemoryLocation, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:a82bdd10bc6712efec618737f6d7f2f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to execute a native C/C++ function not compiled using the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> compiler.  <a href="#a82bdd10bc6712efec618737f6d7f2f83">More...</a><br /></td></tr>
<tr class="separator:a82bdd10bc6712efec618737f6d7f2f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cda8fae6b4fbed4431a5a5c9a0fb88a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#a2cda8fae6b4fbed4431a5a5c9a0fb88a">EnqueueMarkerWithWaitList</a> ([In] IntPtr commandQueue, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:a2cda8fae6b4fbed4431a5a5c9a0fb88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a marker command which waits for either a list of events to complete, or all previously enqueued commands to complete.  <a href="#a2cda8fae6b4fbed4431a5a5c9a0fb88a">More...</a><br /></td></tr>
<tr class="separator:a2cda8fae6b4fbed4431a5a5c9a0fb88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677a3c66601a1e8d8584be16b845c940"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#a677a3c66601a1e8d8584be16b845c940">EnqueueBarrierWithWaitList</a> ([In] IntPtr commandQueue, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:a677a3c66601a1e8d8584be16b845c940"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synchronization point that enqueues a barrier operation.  <a href="#a677a3c66601a1e8d8584be16b845c940">More...</a><br /></td></tr>
<tr class="separator:a677a3c66601a1e8d8584be16b845c940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac730509a65a05164d3a769f28e9b1ede"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ac730509a65a05164d3a769f28e9b1ede">EnqueueSvmFree</a> ([In] IntPtr commandQueue, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfSvmPointers, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] svmPointers, [In] IntPtr svmFreePointersCallback, [In] IntPtr userData, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:ac730509a65a05164d3a769f28e9b1ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to free the shared virtual memory allocated using clSVMAlloc or a shared system memory pointer.  <a href="#ac730509a65a05164d3a769f28e9b1ede">More...</a><br /></td></tr>
<tr class="separator:ac730509a65a05164d3a769f28e9b1ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaff10aa176b738302a634c9d2213c25"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#aeaff10aa176b738302a634c9d2213c25">EnqueueSvmMemoryCopy</a> ([In] IntPtr commandQueue, [In] [MarshalAs(UnmanagedType.U4)] uint blockingCopy, [In] IntPtr destinationPointer, [In] IntPtr sourcePointer, [In] UIntPtr size, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:aeaff10aa176b738302a634c9d2213c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to do a memcpy operation.  <a href="#aeaff10aa176b738302a634c9d2213c25">More...</a><br /></td></tr>
<tr class="separator:aeaff10aa176b738302a634c9d2213c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ea99e1a23b37f5f276b4e571b45e77"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#a19ea99e1a23b37f5f276b4e571b45e77">EnqueueSvmMemoryFill</a> ([In] IntPtr commandQueue, [In] IntPtr svmPointer, [In] IntPtr pattern, [In] UIntPtr patternSize, [In] UIntPtr size, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:a19ea99e1a23b37f5f276b4e571b45e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to fill a region in memory with a pattern of a given pattern size.  <a href="#a19ea99e1a23b37f5f276b4e571b45e77">More...</a><br /></td></tr>
<tr class="separator:a19ea99e1a23b37f5f276b4e571b45e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57c7c8eab2d1147e19b41fd7e0109fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ac57c7c8eab2d1147e19b41fd7e0109fe">EnqueueSvmMap</a> ([In] IntPtr commandQueue, [In] [MarshalAs(UnmanagedType.U4)] uint blockingMap, [In] [MarshalAs(UnmanagedType.U8)] <a class="el" href="../../d3/d2b/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands.html#ad74eb478bb825816afea8657fc06400e">MapFlag</a> mapFlag, [In] IntPtr svmPointer, [In] UIntPtr size, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:ac57c7c8eab2d1147e19b41fd7e0109fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command that will allow the host to update a region of a SVM buffer.  <a href="#ac57c7c8eab2d1147e19b41fd7e0109fe">More...</a><br /></td></tr>
<tr class="separator:ac57c7c8eab2d1147e19b41fd7e0109fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86fe394d678c9a53cd80253dc3dfbfa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ac86fe394d678c9a53cd80253dc3dfbfa">EnqueueSvmUnmap</a> ([In] IntPtr commandQueue, [In] IntPtr svmPointer, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:ac86fe394d678c9a53cd80253dc3dfbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to indicate that the host has completed updating the region given by svmPointer and which was specified in a previous call to <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ac57c7c8eab2d1147e19b41fd7e0109fe" title="Enqueues a command that will allow the host to update a region of a SVM buffer. ">EnqueueSvmMap</a>.  <a href="#ac86fe394d678c9a53cd80253dc3dfbfa">More...</a><br /></td></tr>
<tr class="separator:ac86fe394d678c9a53cd80253dc3dfbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41f18f75ff8d74faaaff571089106e2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#aa41f18f75ff8d74faaaff571089106e2">EnqueueSvmMigrateMemory</a> ([In] IntPtr commandQueue, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfSvmPointers, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] svmPointers, [In] [MarshalAs(UnmanagedType.LPArray)] UIntPtr[] sizes, [In] [MarshalAs(UnmanagedType.U8)] <a class="el" href="../../d3/d2b/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands.html#a2a6e8133e55eb1fd7fb5fc882d75b902">MemoryMigrationFlag</a> memoryMigrationFlags, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:aa41f18f75ff8d74faaaff571089106e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to indicate which device a set of ranges of SVM allocations should be associated with.  <a href="#aa41f18f75ff8d74faaaff571089106e2">More...</a><br /></td></tr>
<tr class="separator:aa41f18f75ff8d74faaaff571089106e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86961753a97d858faaa262324a3013a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ac86961753a97d858faaa262324a3013a">EnqueueMarker</a> ([In] IntPtr commandQueue, [In] IntPtr waitEvent)</td></tr>
<tr class="memdesc:ac86961753a97d858faaa262324a3013a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a marker command.  <a href="#ac86961753a97d858faaa262324a3013a">More...</a><br /></td></tr>
<tr class="separator:ac86961753a97d858faaa262324a3013a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47f475765d9a7c80a266fc212be0e0c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ac47f475765d9a7c80a266fc212be0e0c">EnqueueWaitForEvents</a> ([In] IntPtr commandQueue, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList)</td></tr>
<tr class="memdesc:ac47f475765d9a7c80a266fc212be0e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a wait for a specific event or a list of events to complete before any future commands queued in the command-queue are executed.  <a href="#ac47f475765d9a7c80a266fc212be0e0c">More...</a><br /></td></tr>
<tr class="separator:ac47f475765d9a7c80a266fc212be0e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b93ee466c0e1351dc304c11a127bd4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#af2b93ee466c0e1351dc304c11a127bd4">EnqueueBarrier</a> ([In] IntPtr commandQueue)</td></tr>
<tr class="memdesc:af2b93ee466c0e1351dc304c11a127bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synchronization point that enqueues a barrier operation.  <a href="#af2b93ee466c0e1351dc304c11a127bd4">More...</a><br /></td></tr>
<tr class="separator:af2b93ee466c0e1351dc304c11a127bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0c62979c464aa2beffdc0538165b1f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#aae0c62979c464aa2beffdc0538165b1f">EnqueueTask</a> ([In] IntPtr commandQueue, [In] IntPtr kernel, [In] [MarshalAs(UnmanagedType.U4)] uint numberOfEventsInWaitList, [In] [MarshalAs(UnmanagedType.LPArray)] IntPtr[] eventWaitList, [Out] out IntPtr waitEvent)</td></tr>
<tr class="memdesc:aae0c62979c464aa2beffdc0538165b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to execute a kernel on a device.  <a href="#aae0c62979c464aa2beffdc0538165b1f">More...</a><br /></td></tr>
<tr class="separator:aae0c62979c464aa2beffdc0538165b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a wrapper for the native methods of the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> Enqueued Commands API. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af2b93ee466c0e1351dc304c11a127bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b93ee466c0e1351dc304c11a127bd4">&#9670;&nbsp;</a></span>EnqueueBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueBarrier </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A synchronization point that enqueues a barrier operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>A valid command-queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="a677a3c66601a1e8d8584be16b845c940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677a3c66601a1e8d8584be16b845c940">&#9670;&nbsp;</a></span>EnqueueBarrierWithWaitList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueBarrierWithWaitList </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A synchronization point that enqueues a barrier operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>A valid host command queue.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular kernel-instance. Event objects are unique and can be used to identify a particular kernel execution instance later on. If event is <code>null</code>, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="a6c4de495720879ccc8d62026a9e5891f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4de495720879ccc8d62026a9e5891f">&#9670;&nbsp;</a></span>EnqueueCopyBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueCopyBuffer </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>sourceBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>destinationBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>sourceOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>destinationOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to copy from one buffer object to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Is a valid host command-queue in which the write command will be queued. commandQueue and buffer must be created with the same <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context.</td></tr>
    <tr><td class="paramname">sourceBuffer</td><td>A valid source buffer object.</td></tr>
    <tr><td class="paramname">destinationBuffer</td><td>A valid destination buffer object.</td></tr>
    <tr><td class="paramname">sourceOffset</td><td>The offset where to begin copying data from sourceBuffer.</td></tr>
    <tr><td class="paramname">destinationOffset</td><td>The offset where to begin copying data into destinationBuffer.</td></tr>
    <tr><td class="paramname">size</td><td>Refers to the size in bytes to copy.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="aab0ea05825a0696d2b864a9325eeab45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0ea05825a0696d2b864a9325eeab45">&#9670;&nbsp;</a></span>EnqueueCopyBufferRectangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueCopyBufferRectangle </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>sourceBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>destinationBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>sourceOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>destinationOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>sourceRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>sourceSlicePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>destinationRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>destinationSlicePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to copy a 2D or 3D rectangular region from a buffer object to another buffer object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>The host command-queue in which the copy command will be queued. The <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context associated with commandQueue, sourceBuffer, and destinationBuffer must be the same. </td></tr>
    <tr><td class="paramname">sourceBuffer</td><td>A valid source buffer object.</td></tr>
    <tr><td class="paramname">destinationBuffer</td><td>A valid destination buffer object.</td></tr>
    <tr><td class="paramname">sourceOrigin</td><td>The (x, y, z) offset in the memory region associated with sourceBuffer. For a 2D rectangle region, the z value given by <code>sourceOrigin[2]</code> should be 0. The offset in bytes is computed as <code>sourceOrigin[2] * sourceSlicePitch + sourceOrigin[1] * sourceRowPitch + sourceOrigin[0]</code>. </td></tr>
    <tr><td class="paramname">destinationOrigin</td><td>The (x, y, z) offset in the memory region associated with destinationBuffer. For a 2D rectangle region, the z value given by <code>destinationOrigin[2]</code> should be 0. The offset in bytes is computed as <code>destinationOrigin[2] * destinationSlicePitch + destinationOrigin[1] * destinationRowPitch + destinationOrigin[0]</code>. </td></tr>
    <tr><td class="paramname">region</td><td>The (width in bytes, height in rows, depth in slices) in bytes of the 2D or 3D rectangle being copied. For a 2D rectangle, the depth value given by <code>region[2]</code> should be 1. The values in region cannot be 0. </td></tr>
    <tr><td class="paramname">sourceRowPitch</td><td>The length of each row in bytes to be used for the memory region associated with sourceBuffer. If sourceRowPitch is 0, sourceRowPitch is computed as <code>region[0]</code>. </td></tr>
    <tr><td class="paramname">sourceSlicePitch</td><td>The length of each 2D slice in bytes to be used for the memory region associated with sourceBuffer. If sourceSlicePitch is 0, sourceSlicePitch is computed as <code>region[1] * sourceRowPitch</code>. </td></tr>
    <tr><td class="paramname">destinationRowPitch</td><td>The length of each row in bytes to be used for the memory region associated with destinationBuffer. If destinationRowPitch is 0, destinationRowPitch is computed as <code>region[0]</code>. </td></tr>
    <tr><td class="paramname">destinationSlicePitch</td><td>The length of each 2D slice in bytes to be used for the memory region associated with destinationBuffer. If destinationSlicePitch is 0, destinationSlicePitch is computed as <code>region[1] * destinationRowPitch</code>. </td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="a77814dc417fc7d59edb59a97310d9732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77814dc417fc7d59edb59a97310d9732">&#9670;&nbsp;</a></span>EnqueueCopyBufferToImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueCopyBufferToImage </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>sourceBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>destinationImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>sourceOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>destinationOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to copy a buffer object to an image object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Must be a valid host command-queue. The <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context associated with commandQueue, sourceBuffer, and destinationImage must be the same.</td></tr>
    <tr><td class="paramname">sourceBuffer</td><td>A valid buffer object.</td></tr>
    <tr><td class="paramname">destinationImage</td><td>A valid image object.</td></tr>
    <tr><td class="paramname">sourceOffset</td><td>The offset where to begin copying data from sourceBuffer.</td></tr>
    <tr><td class="paramname">destinationOrigin</td><td>Defines the (x, y, z) offset in pixels in the 1D, 2D or 3D image, the (x, y) offset and the image index in the 2D image array or the (x) offset and the image index in the 1D image array. If destinationImage is a 2D image object, <code>destinationOrigin[2]</code> must be 0. If destinationImage is a 1D image or 1D image buffer object, <code>destinationOrigin[1]</code> and <code>destinationOrigin[2]</code> must be 0. If destinationImage is a 1D image array object, <code>destinationOrigin[2]</code> must be 0. If destinationImage is a 1D image array object, <code>destinationOrigin[1]</code> describes the image index in the 1D image array. If destinationImage is a 2D image array object, <code>destinationOrigin[2]</code> describes the image index in the 2D image array. </td></tr>
    <tr><td class="paramname">region</td><td>Defines the (width, height, depth) in pixels of the 1D, 2D or 3D rectangle, the (width, height) in pixels of the 2D rectangle and the number of images of a 2D image array or the (width) in pixels of the 1D rectangle and the number of images of a 1D image array. If destinationImage is a 2D image object, <code>region[2]</code> must be 1. If destinationImage is a 1D image or 1D image buffer object, <code>region[1]</code> and <code>region[2]</code> must be 1. If destinationImage is a 1D image array object, <code>region[2]</code> must be 1. The values in region cannot be 0. The size in bytes of the region to be copied from sourceBuffer referred to as src_cb is computed as width * height * depth * bytes/image_element if destinationImage is a 3D image object, is computed as width * height * bytes/image_element if destinationImage is a 2D image, is computed as width * height * arraysize * bytes/image_element if destinationImage is a 2D image array object, is computed as width * bytes/image_element if destinationImage is a 1D image or 1D image buffer object and is computed as width * arraysize * bytes/image_element if destinationImage is a 1D image array object. </td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="a7a8424f6d9d2b5401d508e4a827f002b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8424f6d9d2b5401d508e4a827f002b">&#9670;&nbsp;</a></span>EnqueueCopyImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueCopyImage </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>sourceImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>destinationImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>sourceOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>destinationOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to copy image objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Refers to the host command-queue in which the copy command will be queued. The <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context associated with commandQueue, sourceImage and destinationImage must be the same. </td></tr>
    <tr><td class="paramname">sourceImage</td><td>Can be 1D, 2D, 3D image or a 1D, 2D image array objects. It is possible to copy subregions between any combinations of source and destination types, provided that the dimensions of the subregions are the same e.g., one can copy a rectangular region from a 2D image to a slice of a 3D image. </td></tr>
    <tr><td class="paramname">destinationImage</td><td>Can be 1D, 2D, 3D image or a 1D, 2D image array objects. It is possible to copy subregions between any combinations of source and destination types, provided that the dimensions of the subregions are the same e.g., one can copy a rectangular region from a 2D image to a slice of a 3D image. </td></tr>
    <tr><td class="paramname">sourceOrigin</td><td>Defines the (x, y, z) offset in pixels in the 1D, 2D or 3D image, the (x, y) offset and the image index in the 2D image array or the (x) offset and the image index in the 1D image array. If image is a 2D image object, <code>sourceOrigin[2]</code> must be 0. If sourceImage is a 1D image object, <code>sourceOrigin[1]</code> and <code>sourceOrigin[2]</code> must be 0. If sourceImage is a 1D image array object, <code>sourceOrigin[2]</code> must be 0. If sourceImage is a 1D image array object, <code>sourceOrigin[1]</code> describes the image index in the 1D image array. If sourceImage is a 2D image array object, <code>sourceOrigin[2]</code> describes the image index in the 2D image array. </td></tr>
    <tr><td class="paramname">destinationOrigin</td><td>Defines the (x, y, z) offset in pixels in the 1D, 2D or 3D image, the (x, y) offset and the image index in the 2D image array or the (x) offset and the image index in the 1D image array. If destinationImage is a 2D image object, <code>destinationOrigin[2]</code> must be 0. If destinationImage is a 1D image or 1D image buffer object, <code>destinationOrigin[1]</code> and <code>destinationOrigin[2]</code> must be 0. If destinationImage is a 1D image array object, <code>destinationOrigin[2]</code> must be 0. If destinationImage is a 1D image array object, <code>destinationOrigin[1]</code> describes the image index in the 1D image array. If destinationImage is a 2D image array object, <code>destinationOrigin[2]</code> describes the image index in the 2D image array. </td></tr>
    <tr><td class="paramname">region</td><td>Defines the (width, height, depth) in pixels of the 1D, 2D or 3D rectangle, the (width, height) in pixels of the 2D rectangle and the number of images of a 2D image array or the (width) in pixels of the 1D rectangle and the number of images of a 1D image array. If sourceImage or destinationImage is a 2D image object, <code>region[2]</code> must be 1. If sourceImage or destinationImage is a 1D image or 1D image buffer object, <code>region[1]</code> and <code>region[2]</code> must be 1. If sourceImage or destinationImage is a 1D image array object, <code>region[2]</code> must be 1. The values in region cannot be 0. </td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="adf71756eda0bcb4246d48bed1ed6c885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf71756eda0bcb4246d48bed1ed6c885">&#9670;&nbsp;</a></span>EnqueueCopyImageToBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueCopyImageToBuffer </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>sourceImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>destinationBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>sourceOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>destinationOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to copy an image object to a buffer object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Must be a valid host command-queue. The <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context associated with commandQueue, sourceImage, and destinationBuffer must be the same.</td></tr>
    <tr><td class="paramname">sourceImage</td><td>A valid image object.</td></tr>
    <tr><td class="paramname">destinationBuffer</td><td>A valid buffer object.</td></tr>
    <tr><td class="paramname">sourceOrigin</td><td>Defines the (x, y, z) offset in pixels in the 1D, 2D or 3D image, the (x, y) offset and the image index in the 2D image array or the (x) offset and the image index in the 1D image array. If image is a 2D image object, <code>sourceOrigin[2]</code> must be 0. If sourceImage is a 1D image object, <code>sourceOrigin[1]</code> and <code>sourceOrigin[2]</code> must be 0. If sourceImage is a 1D image array object, <code>sourceOrigin[2]</code> must be 0. If sourceImage is a 1D image array object, <code>sourceOrigin[1]</code> describes the image index in the 1D image array. If sourceImage is a 2D image array object, <code>sourceOrigin[2]</code> describes the image index in the 2D image array. </td></tr>
    <tr><td class="paramname">region</td><td>Defines the (width, height, depth) in pixels of the 1D, 2D or 3D rectangle, the (width, height) in pixels of the 2D rectangle and the number of images of a 2D image array or the (width) in pixels of the 1D rectangle and the number of images of a 1D image array. If sourceImage or destinationImage is a 2D image object, <code>region[2]</code> must be 1. If sourceImage or destinationImage is a 1D image or 1D image buffer object, <code>region[1]</code> and <code>region[2]</code> must be 1. If sourceImage or destinationImage is a 1D image array object, <code>region[2]</code> must be 1. The values in region cannot be 0. </td></tr>
    <tr><td class="paramname">destinationOffset</td><td>Refers to the offset where to begin copying data into destinationBuffer. The size in bytes of the region to be copied referred to as dst_cb is computed as width * height * depth * bytes/image element if sourceImage is a 3D image object, is computed as width * height * bytes/image element if sourceImage is a 2D image, is computed as width * height * arraysize * bytes/image element if sourceImage is a 2D image array object, is computed as width * bytes/image element if sourceImage is a 1D image or 1D image buffer object and is computed as width * arraysize * bytes/image element if sourceImage is a 1D image array object. </td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="ab7f28918e717b0f4911809a9c25d044f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f28918e717b0f4911809a9c25d044f">&#9670;&nbsp;</a></span>EnqueueFillBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueFillBuffer </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>patternSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to fill a buffer object with a pattern of a given pattern size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Is a valid host command-queue in which the write command will be queued. commandQueue and buffer must be created with the same <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context.</td></tr>
    <tr><td class="paramname">buffer</td><td>Refers to a valid buffer object.</td></tr>
    <tr><td class="paramname">pattern</td><td>A pointer to the data pattern of size patternSize in bytes. pattern will be used to fill a region in buffer starting at offset and is size bytes in size. The data pattern must be a scalar or vector integer or floating-point data type. For example, if buffer is to be filled with a pattern of <code>float4</code> values, then pattern will be a pointer to a <code>float4</code> value and patternSize will be <code>sizeof(float4)</code>. The maximum value of patternSize is the size of the largest integer or floating-point vector data type supported by the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> device. The memory associated with pattern can be reused or freed after the function returns.</td></tr>
    <tr><td class="paramname">patternSize</td><td>The size of pattern in bytes.</td></tr>
    <tr><td class="paramname">offset</td><td>The location in bytes of the region being filled in buffer and must be a multiple of patternSize.</td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of region being filled in buffer and must be a multiple of patternSize.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="adeb3064e525732246d0c3344a951f739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb3064e525732246d0c3344a951f739">&#9670;&nbsp;</a></span>EnqueueFillImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueFillImage </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>fillColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to fill an image object with a specified color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Refers to the host command-queue in which the fill command will be queued. The <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context associated with commandQueue and image must be the same.</td></tr>
    <tr><td class="paramname">image</td><td>A valid image object.</td></tr>
    <tr><td class="paramname">fillColor</td><td>The color used to fill the image. The fill color is a single floating point value if the channel order is <code>ChannelOrder.Depth</code>. Otherwise, the fill color is a four component RGBA floating-point color value if the image channel data type is not an unnormalized signed or unsigned integer type, is a four component signed integer value if the image channel data type is an unnormalized signed integer type and is a four component unsigned integer value if the image channel data type is an unnormalized unsigned integer type. The fill color will be converted to the appropriate image channel format and order associated with image as described in sections 6.12.14 and 8.3. </td></tr>
    <tr><td class="paramname">origin</td><td>Defines the (x, y, z) offset in pixels in the 1D, 2D, or 3D image, the (x, y) offset and the image index in the image array or the (x) offset and the image index in the 1D image array. If image is a 2D image object, <code>origin[2]</code> must be 0. If image is a 1D image or 1D image buffer object, <code>origin[1]</code> and <code>origin[2]</code> must be 0. If image is a 1D image array object, <code>origin[2]</code> must be 0. If image is a 1D image array object, <code>origin[1]</code> describes the image index in the 1D image array. If image is a 2D image array object, <code>origin[2]</code> describes the image index in the 2D image array. </td></tr>
    <tr><td class="paramname">region</td><td>Defines the (width, height, depth) in pixels of the 1D, 2D or 3D rectangle, the (width, height) in pixels of the 2D rectangle and the number of images of a 2D image array or the (width) in pixels of the 1D rectangle and the number of images of a 1D image array. If image is a 2D image object, region[2] must be 1. If image is a 1D image or 1D image buffer object, region[1] and region[2] must be 1. If image is a 1D image array object, region[2] must be 1. The values in region cannot be 0. </td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="adc19a7f173de66cf1b2d8b9db7e58ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc19a7f173de66cf1b2d8b9db7e58ddf">&#9670;&nbsp;</a></span>EnqueueMapBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueMapBuffer </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>blockingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U8)] <a class="el" href="../../d3/d2b/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands.html#ad74eb478bb825816afea8657fc06400e">MapFlag</a>&#160;</td>
          <td class="paramname"><em>mapFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.I4)] out <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td>
          <td class="paramname"><em>errorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to map a region of the buffer object given by buffer into the host address space and returns a pointer to this mapped region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Must be a valid host command-queue.</td></tr>
    <tr><td class="paramname">buffer</td><td>A valid buffer object. The <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context associated with commandQueue and buffer must be the same.</td></tr>
    <tr><td class="paramname">blockingMap</td><td>Indicates if the map operation is blocking or non-blocking. If blockingMap is <code>true</code> (1), <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#adc19a7f173de66cf1b2d8b9db7e58ddf" title="Enqueues a command to map a region of the buffer object given by buffer into the host address space a...">EnqueueMapBuffer</a> does not return until the specified region in buffer is mapped into the host address space and the application can access the contents of the mapped region using the pointer returned by <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#adc19a7f173de66cf1b2d8b9db7e58ddf" title="Enqueues a command to map a region of the buffer object given by buffer into the host address space a...">EnqueueMapBuffer</a>. If blockingMap is <code>false</code> (0), i.e. map operation is non-blocking, the pointer to the mapped region returned by <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#adc19a7f173de66cf1b2d8b9db7e58ddf" title="Enqueues a command to map a region of the buffer object given by buffer into the host address space a...">EnqueueMapBuffer</a> cannot be used until the map command has completed. The event argument returns an event object which can be used to query the execution status of the map command. When the map command is completed, the application can access the contents of the mapped region using the pointer returned by <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#adc19a7f173de66cf1b2d8b9db7e58ddf" title="Enqueues a command to map a region of the buffer object given by buffer into the host address space a...">EnqueueMapBuffer</a>. </td></tr>
    <tr><td class="paramname">mapFlag</td><td>An enumeration with which determines the behavior of the map operation.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in bytes of the region in the buffer object that is being mapped.</td></tr>
    <tr><td class="paramname">size</td><td>The the size in bytes of the region in the buffer object that is being mapped.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
    <tr><td class="paramname">errorCode</td><td>Returns an appropriate error code. If <a class="el" href="../../">is <code>null</code>, no error code is returned.</a> <dl class="section return"><dt>Returns</dt><dd>Returns a pointer that maps a region starting at offset and is at least size bytes in size. The result of a memory access outside this region is undefined.</dd></dl>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade4a513f12c66e75c675810ecdaa36e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4a513f12c66e75c675810ecdaa36e0">&#9670;&nbsp;</a></span>EnqueueMapImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueMapImage </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>blockingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U8)] <a class="el" href="../../d3/d2b/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands.html#ad74eb478bb825816afea8657fc06400e">MapFlag</a>&#160;</td>
          <td class="paramname"><em>mapFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>imageRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>imageSlicePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.I4)] out <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a>&#160;</td>
          <td class="paramname"><em>errorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to map a region of an image object into the host address space and returns a pointer to this mapped region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Must be a valid host command-queue.</td></tr>
    <tr><td class="paramname">image</td><td>A valid image object. The <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context associated with commandQueue and image must be the same.</td></tr>
    <tr><td class="paramname">blockingMap</td><td>Indicates if the map operation is blocking or non-blocking. If blockingMap is <code>true</code> (1), <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#adc19a7f173de66cf1b2d8b9db7e58ddf" title="Enqueues a command to map a region of the buffer object given by buffer into the host address space a...">EnqueueMapBuffer</a> does not return until the specified region in buffer is mapped into the host address space and the application can access the contents of the mapped region using the pointer returned by <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#adc19a7f173de66cf1b2d8b9db7e58ddf" title="Enqueues a command to map a region of the buffer object given by buffer into the host address space a...">EnqueueMapBuffer</a>. If blockingMap is <code>false</code> (0), i.e. map operation is non-blocking, the pointer to the mapped region returned by <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#adc19a7f173de66cf1b2d8b9db7e58ddf" title="Enqueues a command to map a region of the buffer object given by buffer into the host address space a...">EnqueueMapBuffer</a> cannot be used until the map command has completed. The event argument returns an event object which can be used to query the execution status of the map command. When the map command is completed, the application can access the contents of the mapped region using the pointer returned by <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#adc19a7f173de66cf1b2d8b9db7e58ddf" title="Enqueues a command to map a region of the buffer object given by buffer into the host address space a...">EnqueueMapBuffer</a>. </td></tr>
    <tr><td class="paramname">mapFlag</td><td>An enumeration with which determines the behavior of the map operation.</td></tr>
    <tr><td class="paramname">origin</td><td>Defines the (x, y, z) offset in pixels in the 1D, 2D, or 3D image, the (x, y) offset and the image index in the image array or the (x) offset and the image index in the 1D image array. If image is a 2D image object, <code>origin[2]</code> must be 0. If image is a 1D image or 1D image buffer object, <code>origin[1]</code> and <code>origin[2]</code> must be 0. If image is a 1D image array object, <code>origin[2]</code> must be 0. If image is a 1D image array object, <code>origin[1]</code> describes the image index in the 1D image array. If image is a 2D image array object, <code>origin[2]</code> describes the image index in the 2D image array. </td></tr>
    <tr><td class="paramname">region</td><td>Defines the (width, height, depth) in pixels of the 1D, 2D or 3D rectangle, the (width, height) in pixels of the 2D rectangle and the number of images of a 2D image array or the (width) in pixels of the 1D rectangle and the number of images of a 1D image array. If image is a 2D image object, region[2] must be 1. If image is a 1D image or 1D image buffer object, region[1] and region[2] must be 1. If image is a 1D image array object, region[2] must be 1. The values in region cannot be 0. </td></tr>
    <tr><td class="paramname">inputRowPitch</td><td>The length of each row in bytes. This value must be greater than or equal to the element size in bytes * width. If inputRowPitch is set to 0, the appropriate row pitch is calculated based on the size of each element in bytes multiplied by width. </td></tr>
    <tr><td class="paramname">inputSlicePitch</td><td>Size in bytes of the 2D slice of the 3D region of a 3D image or each image of a 1D or 2D image array being read. This must be 0 if image is a 1D or 2D image. Otherwise this value must be greater than or equal to <code>inputRowPitch * height</code>. If inputSlicePitch is set to 0, the appropriate slice pitch is calculated based on the <code>inputRowPitch * height</code>. </td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
    <tr><td class="paramname">errorCode</td><td>Returns an appropriate error code. If <a class="el" href="../../">is <code>null</code>, no error code is returned.</a> <dl class="section return"><dt>Returns</dt><dd>Returns a pointer that maps a 1D, 2D or 3D region starting at origin and is at least <code>region[0]</code> pixels in size for a 1D image, 1D image buffer or 1D image array, <code>(imageRowPitch * region[1])</code> pixels in size for a 2D image or 2D image array, and <code>(imageSlicePitch * region[2])</code> pixels in size for a 3D image. The result of a memory access outside this region is undefined. </dd></dl>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac86961753a97d858faaa262324a3013a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86961753a97d858faaa262324a3013a">&#9670;&nbsp;</a></span>EnqueueMarker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueMarker </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a marker command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>A valid host command queue.</td></tr>
    <tr><td class="paramname">waitEvent</td><td>The event object that serves as marker.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="a2cda8fae6b4fbed4431a5a5c9a0fb88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cda8fae6b4fbed4431a5a5c9a0fb88a">&#9670;&nbsp;</a></span>EnqueueMarkerWithWaitList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueMarkerWithWaitList </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a marker command which waits for either a list of events to complete, or all previously enqueued commands to complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>A valid host command-queue.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular kernel-instance. Event objects are unique and can be used to identify a particular kernel execution instance later on. If event is <code>null</code>, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="abf74d6492434979be80fbb4d6732dbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf74d6492434979be80fbb4d6732dbea">&#9670;&nbsp;</a></span>EnqueueMigrateMemorysObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueMigrateMemorysObjects </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfMemoryObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>memoryObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U8)] <a class="el" href="../../d3/d2b/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands.html#a2a6e8133e55eb1fd7fb5fc882d75b902">MemoryMigrationFlag</a>&#160;</td>
          <td class="paramname"><em>memoryMigrationFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to indicate which device a set of memory objects should be associated with. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>A valid host command-queue. The specified set of memory objects in memoryObjects will be migrated to the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> device associated with commandQueue or to the host if the <code><a class="el" href="../../d3/d2b/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands.html#a2a6e8133e55eb1fd7fb5fc882d75b902ac2ca16d048ec66e04bca283eab048ec2" title="This flag indicates that the specified set of memory objects are to be migrated to the host...">MemoryMigrationFlag.Host</a></code> has been specified. </td></tr>
    <tr><td class="paramname">numberOfMemoryObjects</td><td>The number of memory objects specified in memoryObjects.</td></tr>
    <tr><td class="paramname">memoryObjects</td><td>A pointer to a list of memory objects.</td></tr>
    <tr><td class="paramname">memoryMigrationFlags</td><td>An enumration that is used to specify migration options.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="a82bdd10bc6712efec618737f6d7f2f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82bdd10bc6712efec618737f6d7f2f83">&#9670;&nbsp;</a></span>EnqueueNativeKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueNativeKernel </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>userFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>argumentSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfMemoryObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>memoryObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>argumentsMemoryLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to execute a native C/C++ function not compiled using the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> compiler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>A valid host command-queue. A native user function can only be executed on a command-queue created on a device that has <code>DeviceExecutionCapabilities.NativeKernel</code> capability set in <code>DeviceInformation.ExecutionCapabilities</code> return by Device.GetDeviceInformation. </td></tr>
    <tr><td class="paramname">userFunction</td><td>A pointer to a host-callable user function.</td></tr>
    <tr><td class="paramname">arguments</td><td>A pointer to the arguments list that userFunction should be called with.</td></tr>
    <tr><td class="paramname">argumentSize</td><td>The size in bytes of the arguments list that arguments points to.</td></tr>
    <tr><td class="paramname">numberOfMemoryObjects</td><td>The number of buffer objects that are passed in arguments.</td></tr>
    <tr><td class="paramname">memoryObjects</td><td>A list of valid buffer objects, if numberOfMemoryObjects is greater than 0. The buffer object values specified in memoryObjects are memory object handles returned by CreateBuffer or <code>null</code>. </td></tr>
    <tr><td class="paramname">argumentsMemoryLocation</td><td>A pointer to appropriate locations that arguments points to where memory object handles are stored. Before the user function is executed, the memory object handles are replaced by pointers to global memory. </td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular kernel-instance. Event objects are unique and can be used to identify a particular kernel execution instance later on. If event is <code>null</code>, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="a1475364cd3cfbfaea7a4ea8ea39c6c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1475364cd3cfbfaea7a4ea8ea39c6c16">&#9670;&nbsp;</a></span>EnqueueNDRangeKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueNDRangeKernel </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>workDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr []&#160;</td>
          <td class="paramname"><em>globalWorkOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr []&#160;</td>
          <td class="paramname"><em>globalWorkSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr []&#160;</td>
          <td class="paramname"><em>localWorkSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to execute a kernel on a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>A valid host command-queue. The kernel will be queued for execution on the device associated with commandQueue.</td></tr>
    <tr><td class="paramname">kernel</td><td>A valid kernel object. The <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context associated with kernel and commandQueue must be the same.</td></tr>
    <tr><td class="paramname">workDimension</td><td>The number of dimensions used to specify the global work-items and work-items in the work-group.</td></tr>
    <tr><td class="paramname">globalWorkOffset</td><td>Can be used to specify an array of workDimension unsigned values that describe the offset used to calculate the global ID of a work-item. If globalWorkOffset is <code>null</code>, the global IDs start at offset (0, 0, ... 0). </td></tr>
    <tr><td class="paramname">globalWorkSize</td><td>Points to an array of workDimension unsigned values that describe the number of global work-items in workDimension dimensions that will execute the kernel function. The total number of global work-items is computed as globalWorkSize[0] *...* globalWorkSize[workDimension - 1]. </td></tr>
    <tr><td class="paramname">localWorkSize</td><td>Points to an array of workDimension unsigned values that describe the number of work-items that make up a work-group (also referred to as the size of the work-group) that will execute the kernel specified by kernel. The total number of work-items in a work-group is computed as localWorkSize[0] *... * localWorkSize[workDimension - 1]. </td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular kernel-instance. Event objects are unique and can be used to identify a particular kernel execution instance later on. If event is <code>null</code>, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="a0012554c7ef3f6eec4d67274b159420f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0012554c7ef3f6eec4d67274b159420f">&#9670;&nbsp;</a></span>EnqueueReadBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueReadBuffer </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>blockingRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue commands to read from a buffer object to host memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Is a valid host command-queue in which the read command will be queued. commandQueue and buffer must be created with the same <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context.</td></tr>
    <tr><td class="paramname">buffer</td><td>Refers to a valid buffer object.</td></tr>
    <tr><td class="paramname">blockingRead</td><td>Indicates if the read operations are blocking or non-blocking.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in bytes in the buffer object to read from.</td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of data being read.</td></tr>
    <tr><td class="paramname">pointer</td><td>The pointer to buffer in host memory where data is to be read into.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular kernel-instance. Event objects are unique and can be used to identify a particular kernel execution instance later on. If event is <code>null</code>, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="aa2cac4992c3136e0bcb6fe6e74c9b2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cac4992c3136e0bcb6fe6e74c9b2ae">&#9670;&nbsp;</a></span>EnqueueReadBufferRectangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueReadBufferRectangle </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>blockingRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>bufferOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>hostOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>bufferRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>bufferSlicePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>hostRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>hostSlicePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue command to read from a 2D or 3D rectangular region from a buffer object to host memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Is is a valid host command-queue in which the read command will be queued. commandQueue and buffer must be created with the same <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context.</td></tr>
    <tr><td class="paramname">buffer</td><td>Refers to a valid buffer object.</td></tr>
    <tr><td class="paramname">blockingRead</td><td>Indicates if the read operations are blocking or non-blocking. If blockingRead is <code>true</code> (1) i.e. the read command is blocking, <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#aa2cac4992c3136e0bcb6fe6e74c9b2ae" title="Enqueue command to read from a 2D or 3D rectangular region from a buffer object to host memory...">EnqueueReadBufferRectangle</a> does not return until the buffer data has been read and copied into memory pointed to by pointer. If blockingRead is <code>false</code> (0) i.e. the read command is non-blocking, <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#aa2cac4992c3136e0bcb6fe6e74c9b2ae" title="Enqueue command to read from a 2D or 3D rectangular region from a buffer object to host memory...">EnqueueReadBufferRectangle</a> queues a non-blocking read command and returns. The contents of the buffer that pointer points to cannot be used until the read command has completed. The event argument argument returns an event object which can be used to query the execution status of the read command. When the read command has completed, the contents of the buffer that pointer points to can be used by the application. </td></tr>
    <tr><td class="paramname">bufferOrigin</td><td>The (x, y, z) offset in the memory region associated with buffer. For a 2D rectangle region, the z value given by <code>bufferOrigin[2]</code> should be 0. The offset in bytes is computed as <code>bufferOrigin[2] * bufferSlicePitch + bufferOrigin[1] * bufferRowPitch + bufferOrigin[0]</code>. </td></tr>
    <tr><td class="paramname">hostOrigin</td><td>The (x, y, z) offset in the memory region pointed to by pointer. For a 2D rectangle region, the z value given by <code>hostOrigin[2]</code> should be 0. The offset in bytes is computed as <code>hostOrigin[2] * hostSlicePitch + hostOrigin[1] * hostRowPitch + hostOrigin[0]</code>. </td></tr>
    <tr><td class="paramname">region</td><td>The (width in bytes, height in rows, depth in slices) of the 2D or 3D rectangle being read or written. For a 2D rectangle copy, the depth value given by <code>region[2]</code> should be 1. The values in region cannot be 0. </td></tr>
    <tr><td class="paramname">bufferRowPitch</td><td>The length of each row in bytes to be used for the memory region associated with buffer. If bufferRowPitch is 0, bufferRowPitch is computed as <code>region[0]</code>.</td></tr>
    <tr><td class="paramname">bufferSlicePitch</td><td>The length of each 2D slice in bytes to be used for the memory region associated with buffer. If bufferSlicePitch is 0, bufferSlicePitch is computed as <code>region[1] * bufferRowPitch</code>. </td></tr>
    <tr><td class="paramname">hostRowPitch</td><td>The length of each row in bytes to be used for the memory region pointed to by pointer. If hostRowPitch is 0, hostRowPitch is computed as <code>region[0]</code>.</td></tr>
    <tr><td class="paramname">hostSlicePitch</td><td>The length of each 2D slice in bytes to be used for the memory region pointed to by pointer. If hostSlicePitch is 0, hostSlicePitch is computed as <code>region[1] * hostRowPitch</code>. </td></tr>
    <tr><td class="paramname">pointer</td><td>The pointer to buffer in host memory where data is to be read into.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular read command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="ac523ddce2a890444ae03cc5bfa17bf21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac523ddce2a890444ae03cc5bfa17bf21">&#9670;&nbsp;</a></span>EnqueueReadImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueReadImage </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>blockingRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>rowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>slicePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue commands to read from an image or image array object to host memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Is a valid host command-queue in which the read command will be queued. commandQueue and buffer must be created with the same <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context.</td></tr>
    <tr><td class="paramname">image</td><td>Refers to a valid image or image array object.</td></tr>
    <tr><td class="paramname">blockingRead</td><td>Indicates if the read operations are blocking or non-blocking. If blockingRead is <code>true</code> (1) i.e. the read command is blocking, <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ac523ddce2a890444ae03cc5bfa17bf21" title="Enqueue commands to read from an image or image array object to host memory. ">EnqueueReadImage</a> does not return until the buffer data has been read and copied into memory pointed to by pointer. If blockingRead is <code>false</code> (0) i.e. the read command is non-blocking, <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ac523ddce2a890444ae03cc5bfa17bf21" title="Enqueue commands to read from an image or image array object to host memory. ">EnqueueReadImage</a> queues a non-blocking read command and returns. The contents of the buffer that pointer points to cannot be used until the read command has completed. The event argument argument returns an event object which can be used to query the execution status of the read command. When the read command has completed, the contents of the buffer that pointer points to can be used by the application. </td></tr>
    <tr><td class="paramname">origin</td><td>Defines the (x, y, z) offset in pixels in the 1D, 2D, or 3D image, the (x, y) offset and the image index in the image array or the (x) offset and the image index in the 1D image array. If image is a 2D image object, <code>origin[2]</code> must be 0. If image is a 1D image or 1D image buffer object, <code>origin[1]</code> and <code>origin[2]</code> must be 0. If image is a 1D image array object, <code>origin[2]</code> must be 0. If image is a 1D image array object, <code>origin[1]</code> describes the image index in the 1D image array. If image is a 2D image array object, <code>origin[2]</code> describes the image index in the 2D image array. </td></tr>
    <tr><td class="paramname">region</td><td>Defines the (width, height, depth) in pixels of the 1D, 2D or 3D rectangle, the (width, height) in pixels of the 2D rectangle and the number of images of a 2D image array or the (width) in pixels of the 1D rectangle and the number of images of a 1D image array. If image is a 2D image object, region[2] must be 1. If image is a 1D image or 1D image buffer object, region[1] and region[2] must be 1. If image is a 1D image array object, region[2] must be 1. The values in region cannot be 0. </td></tr>
    <tr><td class="paramname">rowPitch</td><td>The length of each row in bytes. This value must be greater than or equal to the element size in bytes * width. If rowPitch is set to 0, the appropriate row pitch is calculated based on the size of each element in bytes multiplied by width. </td></tr>
    <tr><td class="paramname">slicePitch</td><td>Size in bytes of the 2D slice of the 3D region of a 3D image or each image of a 1D or 2D image array being read. This must be 0 if image is a 1D or 2D image. Otherwise this value must be greater than or equal to <code>rowPitch * height</code>. If slicePitch is set to 0, the appropriate slice pitch is calculated based on the <code>rowPitch * height</code>. </td></tr>
    <tr><td class="paramname">pointer</td><td>The pointer to a buffer in host memory where image data is to be read from.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="ac730509a65a05164d3a769f28e9b1ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac730509a65a05164d3a769f28e9b1ede">&#9670;&nbsp;</a></span>EnqueueSvmFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueSvmFree </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfSvmPointers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>svmPointers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>svmFreePointersCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to free the shared virtual memory allocated using clSVMAlloc or a shared system memory pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>A valid host command-queue.</td></tr>
    <tr><td class="paramname">numberOfSvmPointers</td><td>The number of SVM pointers stored in svmPointers.</td></tr>
    <tr><td class="paramname">svmPointers</td><td>Specify shared virtual memory pointers to be freed. Each pointer in svmPointers that was allocated using SvmAllocate must have been allocated from the same context from which commandQueue was created. The memory associated with svmPointers can be reused or freed after the function returns. </td></tr>
    <tr><td class="paramname">svmFreePointersCallback</td><td>Specifies the callback function to be called to free the SVM pointers. svmFreePointersCallback takes four arguments: queue which is the command queue in which &lt;see cref"EnqueueSvmFree"/&gt; was enqueued, the count and list of SVM pointers to free and userData which is a pointer to user specified data. If svmFreePointersCallback is <code>null</code>, all pointers specified in svmPointers must be allocated using SvmAllocate and the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> implementation will free these SVM pointers. svmFreePointersCallback must be a valid callback function if any SVM pointer to be freed is a shared system memory pointer i.e. not allocated using SvmAllocate. If svmFreePointersCallback is a valid callback function, the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> implementation will call svmFreePointersCallback to free all the SVM pointers specified in svmPointers. </td></tr>
    <tr><td class="paramname">userData</td><td>Will be passed as the userData argument when svmFreePointersCallback is called. userData can be <code>null</code>.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular kernel-instance. Event objects are unique and can be used to identify a particular kernel execution instance later on. If event is <code>null</code>, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="ac57c7c8eab2d1147e19b41fd7e0109fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57c7c8eab2d1147e19b41fd7e0109fe">&#9670;&nbsp;</a></span>EnqueueSvmMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueSvmMap </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>blockingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U8)] <a class="el" href="../../d3/d2b/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands.html#ad74eb478bb825816afea8657fc06400e">MapFlag</a>&#160;</td>
          <td class="paramname"><em>mapFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>svmPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command that will allow the host to update a region of a SVM buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Must be a valid host command-queue.</td></tr>
    <tr><td class="paramname">blockingMap</td><td>Indicates if the map operation is blocking or non-blocking. If blockingMap is <code>true</code> (1), <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ac57c7c8eab2d1147e19b41fd7e0109fe" title="Enqueues a command that will allow the host to update a region of a SVM buffer. ">EnqueueSvmMap</a> does not return until the application can access the contents of the SVM region specified by svmPointer and size on the host. If blockingMap is <code>false</code> (0), i.e. map operation is non-blocking, the region specified by svmPointer and size cannot be used until the map command has completed. The event argument returns an event object which can be used to query the execution status of the map command. When the map command is completed, the application can access the contents of the region specified by svmPointer and size. </td></tr>
    <tr><td class="paramname">mapFlag</td><td>An enumeration with which determines the behavior of the map operation.</td></tr>
    <tr><td class="paramname">svmPointer</td><td>A pointer to a memory region and size in bytes that will be updated by the host. If svmPointer is allocated using SvmAllocate then it must be allocated from the same context from which commandQueue was created. Otherwise the behavior is undefined. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the memory region that svmPointer points to.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular kernel-instance. Event objects are unique and can be used to identify a particular kernel execution instance later on. If event is <code>null</code>, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="aeaff10aa176b738302a634c9d2213c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaff10aa176b738302a634c9d2213c25">&#9670;&nbsp;</a></span>EnqueueSvmMemoryCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueSvmMemoryCopy </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>blockingCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>destinationPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>sourcePointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to do a memcpy operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Refers to the host command-queue in which the read/write command will be queued. If either destinationPointer or sourcePointer is allocated using SvmAllocate then the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context allocated against must match that of commandQueue. </td></tr>
    <tr><td class="paramname">blockingCopy</td><td>Indicates if the copy operations are blocking or non-blocking. If blockingCopy is <code>true</code> (1), i.e. the copy command is blocking, <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#aeaff10aa176b738302a634c9d2213c25" title="Enqueues a command to do a memcpy operation. ">EnqueueSvmMemoryCopy</a> does not return until the buffer data has been copied into memory pointed to by destinationPointer. If blockingCopy is <code>false</code> (0), i.e. the copy command is non-blocking, <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#aeaff10aa176b738302a634c9d2213c25" title="Enqueues a command to do a memcpy operation. ">EnqueueSvmMemoryCopy</a> queues a non-blocking copy command and returns. The contents of the buffer that destinationPointer point to cannot be used until the copy command has completed. The event argument returns an event object which can be used to query the execution status of the read command. When the copy command has completed, the contents of the buffer that destinationPointer points to can be used by the application. </td></tr>
    <tr><td class="paramname">destinationPointer</td><td>The pointer to a host or SVM memory allocation where data is copied to.</td></tr>
    <tr><td class="paramname">sourcePointer</td><td>The pointer to a memory region where data is copied from. If the memory allocation(s) containing destinationPointer and/or sourcePointer are allocated using SvmAllocate and either is not allocated from the same context from which commandQueue was created the behavior is undefined. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of data being copied.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular kernel-instance. Event objects are unique and can be used to identify a particular kernel execution instance later on. If event is <code>null</code>, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="a19ea99e1a23b37f5f276b4e571b45e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ea99e1a23b37f5f276b4e571b45e77">&#9670;&nbsp;</a></span>EnqueueSvmMemoryFill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueSvmMemoryFill </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>svmPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>patternSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to fill a region in memory with a pattern of a given pattern size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Refers to the host command-queue in which the fill command will be queued. The <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context associated with commandQueue and SVM pointer referred to by svmPointer must be the same. </td></tr>
    <tr><td class="paramname">svmPointer</td><td>A pointer to a memory region that will be filled with pattern. It must be aligned to patternSize bytes. If svmPointer is allocated using SvmAllocate then it must be allocated from the same context from which commandQueue was created. Otherwise the behavior is undefined. </td></tr>
    <tr><td class="paramname">pattern</td><td>A pointer to the data pattern of size patternSize in bytes. pattern will be used to fill a region in buffer starting at offset and is size bytes in size. The data pattern must be a scalar or vector integer or floating-point data type. For example, if buffer is to be filled with a pattern of <code>float4</code> values, then pattern will be a pointer to a <code>float4</code> value and patternSize will be <code>sizeof(float4)</code>. The maximum value of patternSize is the size of the largest integer or floating-point vector data type supported by the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> device. The memory associated with pattern can be reused or freed after the function returns.</td></tr>
    <tr><td class="paramname">patternSize</td><td>The size of pattern in bytes.</td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of region being filled starting with svmPointer and must be a multiple of patternSize.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular kernel-instance. Event objects are unique and can be used to identify a particular kernel execution instance later on. If event is <code>null</code>, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="aa41f18f75ff8d74faaaff571089106e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41f18f75ff8d74faaaff571089106e2">&#9670;&nbsp;</a></span>EnqueueSvmMigrateMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueSvmMigrateMemory </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfSvmPointers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>svmPointers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U8)] <a class="el" href="../../d3/d2b/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands.html#a2a6e8133e55eb1fd7fb5fc882d75b902">MemoryMigrationFlag</a>&#160;</td>
          <td class="paramname"><em>memoryMigrationFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to indicate which device a set of ranges of SVM allocations should be associated with. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>A valid host command queue. The specified set of allocation ranges will be migrated to the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> device associated with commandQueue.</td></tr>
    <tr><td class="paramname">numberOfSvmPointers</td><td>The number of pointers in the specified svmPointers array, and the number of sizes in the sizes array, if sizes is not <code>null</code>.</td></tr>
    <tr><td class="paramname">svmPointers</td><td></td></tr>
    <tr><td class="paramname">sizes</td><td>A pointer to an array of pointers. Each pointer in this array must be within an allocation produced by a call to SvmAllocate.</td></tr>
    <tr><td class="paramname">memoryMigrationFlags</td><td>An enumeration that is used to specify migration options.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular kernel-instance. Event objects are unique and can be used to identify a particular kernel execution instance later on. If event is <code>null</code>, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="ac86fe394d678c9a53cd80253dc3dfbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86fe394d678c9a53cd80253dc3dfbfa">&#9670;&nbsp;</a></span>EnqueueSvmUnmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueSvmUnmap </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>svmPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to indicate that the host has completed updating the region given by svmPointer and which was specified in a previous call to <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ac57c7c8eab2d1147e19b41fd7e0109fe" title="Enqueues a command that will allow the host to update a region of a SVM buffer. ">EnqueueSvmMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Must be a valid host command-queue.</td></tr>
    <tr><td class="paramname">svmPointer</td><td>A pointer that was specified in a previous call to <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ac57c7c8eab2d1147e19b41fd7e0109fe" title="Enqueues a command that will allow the host to update a region of a SVM buffer. ">EnqueueSvmMap</a>. If svmPointer is allocated using SvmAllocate then it must be allocated from the same context from which commandQueue was created. Otherwise the behavior is undefined. </td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular kernel-instance. Event objects are unique and can be used to identify a particular kernel execution instance later on. If event is <code>null</code>, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="aae0c62979c464aa2beffdc0538165b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0c62979c464aa2beffdc0538165b1f">&#9670;&nbsp;</a></span>EnqueueTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueTask </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to execute a kernel on a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>A valid command-queue. The kernel will be queued for execution on the device associated with commandQueue.</td></tr>
    <tr><td class="paramname">kernel</td><td>A valid kernel object. The <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context associated with kernel and commandQueue must be the same.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular kernel-instance. Event objects are unique and can be used to identify a particular kernel execution instance later on. If event is <code>null</code>, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="aa88fb4660b2e42e6255eee66f7765b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88fb4660b2e42e6255eee66f7765b88">&#9670;&nbsp;</a></span>EnqueueUnmapMemoryObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueUnmapMemoryObject </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>memoryObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>mappedPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to unmap a previously mapped region of a memory object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Must be a valid host command-queue.</td></tr>
    <tr><td class="paramname">memoryObject</td><td>A valid memory (buffer or image) object. The <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context associated with commandQueue and memoryObject must be the same.</td></tr>
    <tr><td class="paramname">mappedPointer</td><td>The host address returned by a previous call to <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#adc19a7f173de66cf1b2d8b9db7e58ddf" title="Enqueues a command to map a region of the buffer object given by buffer into the host address space a...">EnqueueMapBuffer</a> or <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#ade4a513f12c66e75c675810ecdaa36e0" title="Enqueues a command to map a region of an image object into the host address space and returns a point...">EnqueueMapImage</a> for memoryObject.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="ac47f475765d9a7c80a266fc212be0e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47f475765d9a7c80a266fc212be0e0c">&#9670;&nbsp;</a></span>EnqueueWaitForEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueWaitForEvents </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a wait for a specific event or a list of events to complete before any future commands queued in the command-queue are executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>A valid command-queue.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>Specifies the number of events given by eventWaitList.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td><a class="el" href="../../d6/d6f/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_events.html">Events</a> specified in eventWaitList act as synchronization points. The context associated with events in eventWaitList and commandQueue must be the same. Each event in eventWaitList </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="a1793e532cd163b1c78963d99d1423080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1793e532cd163b1c78963d99d1423080">&#9670;&nbsp;</a></span>EnqueueWriteBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueWriteBuffer </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>blockingWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue commands to write to a buffer object from host memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Is a valid host command-queue in which the write command will be queued. commandQueue and buffer must be created with the same <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context.</td></tr>
    <tr><td class="paramname">buffer</td><td>Refers to a valid buffer object.</td></tr>
    <tr><td class="paramname">blockingWrite</td><td>Indicates if the write operations are blocking or non-blocking. If blockingWrite is <code>true</code> (1), the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> implementation copies the data referred to by pointer and enqueues the write operation in the command-queue. The memory pointed to by pointer can be reused by the application after the <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#a1793e532cd163b1c78963d99d1423080" title="Enqueue commands to write to a buffer object from host memory. ">EnqueueWriteBuffer</a> call returns. If blocking_write is <code>false</code> (0), the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> implementation will use pointer to perform a non-blocking write. As the write is non-blocking the implementation can return immediately. The memory pointed to by pointer cannot be reused by the application after the call returns. The event argument returns an event object which can be used to query the execution status of the write command. When the write command has completed, the memory pointed to by pointer can then be reused by the application. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset in bytes in the buffer object to write to.</td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of data being written.</td></tr>
    <tr><td class="paramname">pointer</td><td>The pointer to buffer in host memory where data is to be written from.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="af70d737cc3f6697f742c7d6bbe1ca954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70d737cc3f6697f742c7d6bbe1ca954">&#9670;&nbsp;</a></span>EnqueueWriteBufferRectangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueWriteBufferRectangle </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>blockingWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>bufferOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>hostOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>bufferRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>bufferSlicePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>hostRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>hostSlicePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue command to write a 2D or 3D rectangular region to a buffer object from host memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Is a valid host command-queue in which the write command will be queued. commandQueue and buffer must be created with the same <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context.</td></tr>
    <tr><td class="paramname">buffer</td><td>Refers to a valid buffer object.</td></tr>
    <tr><td class="paramname">blockingWrite</td><td>Indicates if the write operations are blocking or non-blocking. If blockingWrite is <code>true</code> (1), the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> implementation copies the data referred to by pointer and enqueues the write operation in the command-queue. The memory pointed to by pointer can be reused by the application after the clEnqueueWriteBufferRect call returns. If blocking_write is <code>false</code> (0), the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> implementation will use pointer to perform a non-blocking write. As the write is non-blocking the implementation can return immediately. The memory pointed to by pointer cannot be reused by the application after the call returns. The event argument returns an event object which can be used to query the execution status of the write command. When the write command has completed, the memory pointed to by pointer can then be reused by the application. </td></tr>
    <tr><td class="paramname">bufferOrigin</td><td>The (x, y, z) offset in the memory region associated with buffer. For a 2D rectangle region, the z value given by <code>bufferOrigin[2]</code> should be 0. The offset in bytes is computed as <code>bufferOrigin[2] * bufferSlicePitch + bufferOrigin[1] * bufferRowPitch + bufferOrigin[0]</code>. </td></tr>
    <tr><td class="paramname">hostOrigin</td><td>The (x, y, z) offset in the memory region pointed to by pointer. For a 2D rectangle region, the z value given by <code>hostOrigin[2]</code> should be 0. The offset in bytes is computed as <code>hostOrigin[2] * hostSlicePitch + hostOrigin[1] * hostRowPitch + hostOrigin[0]</code>. </td></tr>
    <tr><td class="paramname">region</td><td>The (width in bytes, height in rows, depth in slices) of the 2D or 3D rectangle being read or written. For a 2D rectangle copy, the depth value given by <code>region[2]</code> should be 1. The values in region cannot be 0. </td></tr>
    <tr><td class="paramname">bufferRowPitch</td><td>The length of each row in bytes to be used for the memory region associated with buffer. If bufferRowPitch is 0, bufferRowPitch is computed as <code>region[0]</code>.</td></tr>
    <tr><td class="paramname">bufferSlicePitch</td><td>The length of each 2D slice in bytes to be used for the memory region associated with buffer. If bufferSlicePitch is 0, bufferSlicePitch is computed as <code>region[1] * bufferRowPitch</code>. </td></tr>
    <tr><td class="paramname">hostRowPitch</td><td>The length of each row in bytes to be used for the memory region pointed to by pointer. If hostRowPitch is 0, hostRowPitch is computed as <code>region[0]</code>.</td></tr>
    <tr><td class="paramname">hostSlicePitch</td><td>The length of each 2D slice in bytes to be used for the memory region pointed to by pointer. If hostSlicePitch is 0, hostSlicePitch is computed as <code>region[1] * hostRowPitch</code>. </td></tr>
    <tr><td class="paramname">pointer</td><td>The pointer to buffer in host memory where data is to be written from.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<a id="a277ec7cdcd85d5028219690e32812319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277ec7cdcd85d5028219690e32812319">&#9670;&nbsp;</a></span>EnqueueWriteImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdad">Result</a> Engine.OpenCL.DotNetCore.Interop.EnqueuedCommands.EnqueuedCommandsNativeApi.EnqueueWriteImage </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>blockingWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] UIntPtr []&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>inputRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] UIntPtr&#160;</td>
          <td class="paramname"><em>inputSlicePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.U4)] uint&#160;</td>
          <td class="paramname"><em>numberOfEventsInWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPArray)] IntPtr []&#160;</td>
          <td class="paramname"><em>eventWaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] out IntPtr&#160;</td>
          <td class="paramname"><em>waitEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to write to an image or image array object from host memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandQueue</td><td>Refers to the host command-queue in which the write command will be queued. commandQueue and image must be created with the same <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> context.</td></tr>
    <tr><td class="paramname">image</td><td>Refers to a valid image or image array object.</td></tr>
    <tr><td class="paramname">blockingWrite</td><td>Indicates if the write operations are blocking or non-blocking. If blockingWrite is <code>true</code> (1), the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> implementation copies the data referred to by pointer and enqueues the write operation in the command-queue. The memory pointed to by pointer can be reused by the application after the <a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html#a277ec7cdcd85d5028219690e32812319" title="Enqueues a command to write to an image or image array object from host memory. ">EnqueueWriteImage</a> call returns. If blocking_write is <code>false</code> (0), the <a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a> implementation will use pointer to perform a non-blocking write. As the write is non-blocking the implementation can return immediately. The memory pointed to by pointer cannot be reused by the application after the call returns. The event argument returns an event object which can be used to query the execution status of the write command. When the write command has completed, the memory pointed to by pointer can then be reused by the application. </td></tr>
    <tr><td class="paramname">origin</td><td>Defines the (x, y, z) offset in pixels in the 1D, 2D, or 3D image, the (x, y) offset and the image index in the image array or the (x) offset and the image index in the 1D image array. If image is a 2D image object, <code>origin[2]</code> must be 0. If image is a 1D image or 1D image buffer object, <code>origin[1]</code> and <code>origin[2]</code> must be 0. If image is a 1D image array object, <code>origin[2]</code> must be 0. If image is a 1D image array object, <code>origin[1]</code> describes the image index in the 1D image array. If image is a 2D image array object, <code>origin[2]</code> describes the image index in the 2D image array. </td></tr>
    <tr><td class="paramname">region</td><td>Defines the (width, height, depth) in pixels of the 1D, 2D or 3D rectangle, the (width, height) in pixels of the 2D rectangle and the number of images of a 2D image array or the (width) in pixels of the 1D rectangle and the number of images of a 1D image array. If image is a 2D image object, region[2] must be 1. If image is a 1D image or 1D image buffer object, region[1] and region[2] must be 1. If image is a 1D image array object, region[2] must be 1. The values in region cannot be 0. </td></tr>
    <tr><td class="paramname">inputRowPitch</td><td>The length of each row in bytes. This value must be greater than or equal to the element size in bytes * width. If inputRowPitch is set to 0, the appropriate row pitch is calculated based on the size of each element in bytes multiplied by width. </td></tr>
    <tr><td class="paramname">inputSlicePitch</td><td>Size in bytes of the 2D slice of the 3D region of a 3D image or each image of a 1D or 2D image array being read. This must be 0 if image is a 1D or 2D image. Otherwise this value must be greater than or equal to <code>inputRowPitch * height</code>. If inputSlicePitch is set to 0, the appropriate slice pitch is calculated based on the <code>inputRowPitch * height</code>. </td></tr>
    <tr><td class="paramname">pointer</td><td>The pointer to a buffer in host memory where image data is to be written to.</td></tr>
    <tr><td class="paramname">numberOfEventsInWaitList</td><td>The number of event in eventWaitList. If eventWaitList is <code>null</code>, then &lt;see cref="numberOfEventsInWaitList"/ must be 0.</td></tr>
    <tr><td class="paramname">eventWaitList</td><td>Specify events that need to complete before this particular command can be executed. If eventWaitList is <code>null</code>, then this particular command does not wait on any event to complete. </td></tr>
    <tr><td class="paramname">waitEvent</td><td>Returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. event can be <code>null</code> in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. If the eventWaitList and the event arguments are not <code>null</code>, the event argument should not refer to an element of the eventWaitList array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html#a18f6910d4c39980677299dcbed9ebdada505a83f220c02df2f85c3810cd9ceb38" title="The function is executed successfully. ">Result.Success</a></code> if the function is executed successfully. Otherwise, it returns an error.</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>MinorEngine/Engine/OpenCL/DotNetCore/Interop/EnqueuedCommands/EnqueuedCommandsNativeApi.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d1/db6/namespace_engine.html">Engine</a></li><li class="navelem"><a class="el" href="../../d2/d5b/namespace_engine_1_1_open_c_l.html">OpenCL</a></li><li class="navelem"><a class="el" href="../../d5/dfd/namespace_engine_1_1_open_c_l_1_1_dot_net_core.html">DotNetCore</a></li><li class="navelem"><a class="el" href="../../d4/dba/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop.html">Interop</a></li><li class="navelem"><a class="el" href="../../d3/d2b/namespace_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands.html">EnqueuedCommands</a></li><li class="navelem"><a class="el" href="../../d4/d38/class_engine_1_1_open_c_l_1_1_dot_net_core_1_1_interop_1_1_enqueued_commands_1_1_enqueued_commands_native_api.html">EnqueuedCommandsNativeApi</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
